#### 深度优先搜索(超时.jpg)
``` java
class Solution {
    public int vis[]; 
    public List<String> findLadders(String beginWord, String endWord, List<String> wordList) {
        vis = new int[wordList.size()];
        List<Integer> t = new LinkedList<Integer>();
        List<String> ans = new LinkedList<String>();
        for(int i=0;i<wordList.size();i++)
        {
            if( wordList.get(i).equals(endWord) ){
                vis[i] = 1;
                t.add(i);
            }
        }
        if( t.size()==0 ) return ans; // endWord不在字典中
        // 能找到转换序列
        if( findPre(endWord,beginWord,wordList,t) ){
            if( !wordList.get( t.get(t.size()-1) ).equals(beginWord) )
                ans.add(beginWord);
            for(int i=t.size()-1;i>=0;i--)
                ans.add( wordList.get( t.get(i) ) );
        }
        return ans;
    }
    public boolean findPre(String curWord,String endWord,List<String> wordList,List<Integer> ans){
        if( oneDigitDifferent(curWord,endWord) ) return true;
        int length = wordList.size();
        for(int i=0;i<length;i++){
            String temp = wordList.get(i);
            if( vis[i]==0 && oneDigitDifferent(curWord,temp) )
            {
                //System.out.println(i);
                vis[i] = 1;
                ans.add(i);
                if( findPre(temp,endWord,wordList,ans) ) return true;
                vis[i] = 0;
                ans.remove(ans.size()-1);
            }    
        }
        return false;
    }
    // 判断两个字符串是否只有一位不同
    public boolean oneDigitDifferent(String a,String b){
        int cnt = 0;
        for( int i=0;i<a.length();i++ )
            if( a.charAt(i) != b.charAt(i) )
                cnt++;
        return cnt==1;
    } 
}
```
